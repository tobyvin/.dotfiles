#!/usr/bin/env python3

import asyncio
import json
import os
import sys
from asyncio import CancelledError, TaskGroup, run
from collections import defaultdict, deque
from dataclasses import dataclass, field
from functools import cached_property
from itertools import islice

from dbus_next import Variant
from dbus_next.aio import MessageBus
from dbus_next.errors import DBusError

BUS_NAME_PREFIX = "org.mpris.MediaPlayer2."
BUS_NAME_IGNORE = ["playerctld", "kdeconnect"]
OBJECT_PATH = "/org/mpris/MediaPlayer2"
PLAYER_INTERFACE = "org.mpris.MediaPlayer2.Player"
PROPERTIES_INTERFACE = "org.freedesktop.DBus.Properties"


def parse_dbus_values(item: Variant | dict | list) -> dict:
    match item:
        case Variant():
            return parse_dbus_values(item.value)
        case dict(item):
            return {k: parse_dbus_values(v) for k, v in item.items()}
        case list(item):
            return [parse_dbus_values(v) for v in item]
        case v:
            return v


@dataclass
class ScrollingText:
    """Class to produce a rotating string iterator"""

    text: str = ""
    width: int = 10
    deque: deque = field(init=False)
    rotate: bool = field(init=False)

    def __post_init__(self):
        self.rotate = len(self.text) > self.width
        self.deque = deque(list(self.text + " "))

    def update(self, value: str = "") -> None:
        if value == self.text:
            return
        self.text = "" if value is None else value
        self.__post_init__()

    def __iter__(self):
        while self.rotate:
            yield "".join(islice(self.deque, 0, self.width))
            self.deque.rotate(-1)

        yield self.text


class Printer:
    BLACK = f"#{os.environ.get("BASE16_COLOR_00_HEX")}"
    GREEN = f"#{os.environ.get("BASE16_COLOR_0C_HEX")}"
    YELLOW = f"#{os.environ.get("BASE16_COLOR_0A_HEX")}"
    ICONS = {
        "icon": "\U000f075a",  # 󰝚
        "prev": "\U000f04ae",  # 󰒮
        "play": "\U000f040a",  # 󰐊
        "pause": "\U000f03e4",  # 󰏤
        "next": "\U000f04ad",  # 󰒭
        "high": "\U000f057e",  # 󰕾
        "med": "\U000f0580",  # 󰖀
        "low": "\U000f057f",  # 󰕿
    }

    def __init__(self, name, player, width: int = 10):
        self.name = name
        self.text = ScrollingText()
        self.player = player
        self.width = width

    @property
    def player(self):
        return self._player

    @player.setter
    def player(self, value):
        self._player = value
        # clear possibly outdated properties
        # See: https://stackoverflow.com/a/69367025/11477336
        for attr in [
            "title",
            "controls",
            "volume",
            "color",
            "background",
            "short_text",
        ]:
            self.__dict__.pop(attr, None)

        self.text.update(self.title)

    @cached_property
    def title(self) -> str:
        return self.player.get("Metadata", {}).get("xesam:title", "")

    @cached_property
    def controls(self) -> str:
        controls = []

        if self.player.get("CanGoPrevious"):
            controls.append(Printer.ICONS["prev"])

        match self.player.get("PlaybackStatus"):
            case "Playing" if self.player.get("CanPause"):
                controls.append(Printer.ICONS["pause"])
            case _ if self.player.get("CanPlay"):
                controls.append(Printer.ICONS["play"])

        if self.player.get("CanGoNext"):
            controls.append(Printer.ICONS["next"])

        if len(controls) > 0:
            return "  ".join(controls) + " "

    @cached_property
    def volume(self) -> str:
        match self.player.get("Volume"):
            case float(vol) if vol > 0.66:
                return f"{Printer.ICONS["high"]} {vol:.0%}"
            case float(vol) if vol > 0.33:
                return f"{Printer.ICONS["med"]} {vol:.0%}"
            case float(vol):
                return f"{Printer.ICONS["low"]} {vol:.0%}"

    @cached_property
    def background(self):
        match self.player.get("PlaybackStatus"):
            case "Playing":
                return Printer.GREEN
            case "Paused":
                return Printer.YELLOW
            case _:
                return None

    @cached_property
    def color(self):
        match self.player.get("PlaybackStatus"):
            case "Playing" | "Paused":
                return Printer.BLACK
            case _:
                return None

    @cached_property
    def short_text(self) -> str:
        s = f" {Printer.ICONS["icon"]} "
        if c := self.controls:
            s += f" {c} "
        return s

    def status(self) -> dict:
        full_text = ["", Printer.ICONS["icon"], ""]

        if c := self.controls:
            full_text.append(c)

        if v := self.volume:
            full_text.append(v)

        full_text.append("")
        for title in iter(self.text):
            full_text[2] = title
            yield {
                "full_text": " ".join(full_text),
                "short_text": self.short_text,
                "color": self.color,
                "background": self.background,
            }

    async def print(self):
        for status in iter(self.status()):
            print(json.dumps(status, ensure_ascii=False), flush=True)
            await asyncio.sleep(0.5)

    def toggle_name(self):
        if self.text.text == self.name:
            self.text.update(self.title)
        else:
            self.text.update(self.name)


class MPRIS:
    def __init__(self, task_group: TaskGroup):
        self.task_group = task_group
        self.printer_task = None
        self.active_buses: deque(str) = deque([])
        self.bus = None
        self.dbus_iface = None
        self.players = defaultdict(lambda: {})
        self.player_iter = self.players.keys()
        self.ifaces = {}

    @classmethod
    async def connect(cls, task_group: TaskGroup):
        self = cls(task_group)
        self.bus = await MessageBus().connect()

        self.dbus_iface = self.bus.get_proxy_object(
            "org.freedesktop.DBus",
            "/org/freedesktop/DBus",
            await self.bus.introspect("org.freedesktop.DBus", "/org/freedesktop/DBus"),
        ).get_interface("org.freedesktop.DBus")

        for bus_name in await self.dbus_iface.call_list_names():
            if self.valid_player(bus_name):
                await self.add_player(bus_name)

        return self

    @staticmethod
    def valid_player(bus_name: str) -> bool:
        return bus_name.startswith(BUS_NAME_PREFIX) and not any(
            bus_name.removeprefix(BUS_NAME_PREFIX).startswith(n)
            for n in BUS_NAME_IGNORE
        )

    @property
    def active_bus(self) -> str | None:
        if len(self.active_buses) > 0:
            return self.active_buses[-1]

    @property
    def active_player(self) -> Printer | None:
        return self.players.get(self.active_bus)

    @property
    def active_iface(self) -> Printer | None:
        return self.ifaces.get(self.active_bus)

    def cycle_player(self):
        self.active_buses.rotate(-1)
        self.update_printer()

    def update_printer(self):
        if self.printer_task is not None:
            self.printer_task.cancel()

        if player := self.active_player:
            self.printer_task = self.task_group.create_task(player.print())
        else:
            print(flush=True)

    def on_properties_changed(self, bus_name: str, property, invalidated):
        props = parse_dbus_values(property)
        self.players[bus_name].player |= props
        match props:
            case {"PlaybackStatus": "Playing"}:
                if bus_name in self.active_buses:
                    self.active_buses.remove(bus_name)
                self.active_buses.append(bus_name)
            case {"PlaybackStatus": "Stopped"}:
                self.active_buses.remove(bus_name)

        self.update_printer()

    async def add_player(self, bus_name):
        properties = None
        self.players[bus_name] = None
        self.ifaces[bus_name] = None

        obj = self.bus.get_proxy_object(
            bus_name, OBJECT_PATH, await self.bus.introspect(bus_name, OBJECT_PATH)
        )

        properties = obj.get_interface(PROPERTIES_INTERFACE)

        self.players[bus_name] = Printer(
            bus_name.removeprefix(BUS_NAME_PREFIX),
            parse_dbus_values(await properties.call_get_all(PLAYER_INTERFACE)),
        )
        self.ifaces[bus_name] = obj.get_interface(PLAYER_INTERFACE)

        properties.on_properties_changed(
            lambda _, p, i: self.on_properties_changed(bus_name, p, i)
        )

        if bus_name in self.active_buses:
            self.active_buses.remove(bus_name)

        match self.players[bus_name].player.get("PlaybackStatus"):
            case "Playing":
                self.active_buses.append(bus_name)
                self.update_printer()
            case "Paused":
                self.active_buses.appendleft(bus_name)
                self.update_printer()

    def remove_player(self, bus_name):
        self.players.pop(bus_name, None)
        self.ifaces.pop(bus_name, None)
        if bus_name in self.active_buses:
            self.active_buses.remove(bus_name)
            self.update_printer()

    async def on_name_owner_changed(self, bus_name, old, new):
        if self.valid_player(bus_name):
            if old:
                self.remove_player(bus_name)
            if new:
                await self.add_player(bus_name)

    async def listener(self):
        self.dbus_iface.on_name_owner_changed(self.on_name_owner_changed)
        await self.bus.wait_for_disconnect()

    async def button_handler(self):
        loop = asyncio.get_event_loop()
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        await loop.connect_read_pipe(lambda: protocol, sys.stdin)

        while True:
            line = await reader.readline()

            if not line:
                await asyncio.sleep(1)
                continue

            try:
                match json.loads(line):
                    case {"button": 1} if iface := self.active_iface:
                        await iface.call_play_pause()
                    case {"button": 2} if player := self.active_player:
                        player.toggle_name()
                        self.update_printer()
                    case {"button": 3}:
                        self.active_buses.rotate(-1)
                        self.update_printer()
                    case {"button": 4} if iface := self.active_iface:
                        volume = await iface.get_volume()
                        await iface.set_volume(volume + 0.05)
                    case {"button": 5} if iface := self.active_iface:
                        volume = await iface.get_volume()
                        await iface.set_volume(volume - 0.05)
            except DBusError:
                pass


async def main():
    try:
        async with TaskGroup() as task_group:
            mpris = await MPRIS.connect(task_group)
            task_group.create_task(mpris.listener())
            task_group.create_task(mpris.button_handler())
    except CancelledError:
        return


if __name__ == "__main__":
    run(main())
