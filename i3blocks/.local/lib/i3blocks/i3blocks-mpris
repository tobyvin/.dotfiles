#!/usr/bin/env python3

import asyncio
import json
import os
import sys
from asyncio import CancelledError, TaskGroup, run
from pprint import pprint
from collections import defaultdict, deque
from itertools import islice

from dbus_next import Variant
from dbus_next.aio import MessageBus
from dbus_next.errors import DBusError

BUS_NAME_PREFIX = "org.mpris.MediaPlayer2."
BUS_NAME_IGNORE = ["org.mpris.MediaPlayer2.playerctld"]
OBJECT_PATH = "/org/mpris/MediaPlayer2"
PLAYER_INTERFACE = "org.mpris.MediaPlayer2.Player"
PROPERTIES_INTERFACE = "org.freedesktop.DBus.Properties"


def parse_dbus_values(item: Variant | dict | list) -> dict:
    match item:
        case Variant():
            return parse_dbus_values(item.value)
        case dict(item):
            return {k: parse_dbus_values(v) for k, v in item.items()}
        case list(item):
            return [parse_dbus_values(v) for v in item]
        case v:
            return v


class Printer:
    BLACK = f"#{os.environ.get("BASE16_COLOR_00_HEX")}"
    GREEN = f"#{os.environ.get("BASE16_COLOR_0C_HEX")}"
    YELLOW = f"#{os.environ.get("BASE16_COLOR_0A_HEX")}"
    ICONS = {
        "icon": "\U000f075a",  # 󰝚
        "prev": "\U000f04ae ",  # 󰒮
        "play": "\U000f040a ",  # 󰐊
        "pause": "\U000f03e4 ",  # 󰏤
        "next": "\U000f04ad ",  # 󰒭
        "high": "\U000f057e",  # 󰕾
        "med": "\U000f0580",  # 󰖀
        "low": "\U000f057f",  # 󰕿
    }

    FMT = " {icon} {title} {prev} {play_pause} {next} {vol} {volume:.0%} "

    def __init__(self, player, width: int = 10):
        self.player = {}
        self.values = {
            "icon": Printer.ICONS["icon"],
            "prev": "XDELETEX",
            "play_pause": "XDELETEX",
            "next": "XDELETEX",
            "vol": "XDELETEX",
            "volume": 1337,
        }
        self.width = width
        self.iter = [""]
        self.update_props(player)

    def update_props(self, props):
        old_title = self.player.get("Metadata", {}).get("xesam:title")
        self.player |= props

        match self.player.get("Metadata", {}).get("xesam:title"):
            case None:
                pass
            case "":
                self.iter = [""]
            case str(s) if s != old_title:
                self.iter = deque(list(s + " "))

        if self.player.get("CanGoPrevious"):
            self.values["prev"] = Printer.ICONS["prev"]

        match self.player.get("PlaybackStatus"):
            case "Playing" if self.player.get("CanPause"):
                self.values["play_pause"] = Printer.ICONS["pause"]
            case _ if self.player.get("CanPlay"):
                self.values["play_pause"] = Printer.ICONS["play"]

        if self.player.get("CanGoNext"):
            self.values["next"] = Printer.ICONS["next"]

        if self.player.get("Volume"):
            self.values["volume"] = self.player.get("Volume")
        match self.player.get("Volume"):
            case float(vol) if vol > 0.66:
                self.values["vol"] = Printer.ICONS["high"]
            case float(vol) if vol > 0.33:
                self.values["vol"] = Printer.ICONS["med"]
            case float(vol):
                self.values["vol"] = Printer.ICONS["low"]

        match self.player.get("PlaybackStatus"):
            case "Playing":
                self.colors = {
                    "color": Printer.BLACK,
                    "background": Printer.GREEN,
                }
            case "Paused":
                self.colors = {
                    "color": Printer.BLACK,
                    "background": Printer.YELLOW,
                }
            case "Stopped":
                self.colors = {}

    def __iter__(self):
        while self.iter:
            full_text = (
                Printer.FMT.format(
                    title="".join(islice(self.iter, 0, self.width)),
                    **self.values,
                    **self.player,
                )
                .strip()
                .replace("XDELETEX ", "")
                .replace(" 133700%", "")
            )

            output = {"full_text": full_text.center(len(full_text) + 2)}
            output.update(self.colors)
            yield output

            if len(self.iter) > self.width:
                self.iter.rotate(-1)
            else:
                break

    async def print(self):
        for status in iter(self):
            print(json.dumps(status, ensure_ascii=False), flush=True)
            await asyncio.sleep(0.5)


class MPRIS:
    PROPS = ["xesam:title"]

    def __init__(self, task_group: TaskGroup):
        self.task_group = task_group
        self.printer_task = None
        self.active_players = deque([])
        self.bus = None
        self.dbus_iface = None
        self.players = defaultdict(lambda: {})
        self.player_iter = self.players.keys()
        self.ifaces = {}

    @classmethod
    async def connect(cls, task_group: TaskGroup):
        self = cls(task_group)
        self.bus = await MessageBus().connect()

        self.dbus_iface = self.bus.get_proxy_object(
            "org.freedesktop.DBus",
            "/org/freedesktop/DBus",
            await self.bus.introspect("org.freedesktop.DBus", "/org/freedesktop/DBus"),
        ).get_interface("org.freedesktop.DBus")

        for bus_name in await self.dbus_iface.call_list_names():
            if self.valid_player(bus_name):
                await self.add_player(bus_name)

        return self

    @staticmethod
    def valid_player(bus_name: str) -> bool:
        return bus_name.startswith(BUS_NAME_PREFIX) and bus_name not in BUS_NAME_IGNORE

    @property
    def active_player(self):
        if len(self.active_players) > 0:
            return self.active_players[-1]

    def cycle_player(self):
        self.active_players.rotate(-1)
        self.update_printer()

    def update_printer(self):
        if self.printer_task is not None:
            self.printer_task.cancel()

        if len(self.active_players) > 0:
            self.printer_task = self.task_group.create_task(
                self.players[self.active_player].print()
            )
        else:
            print(flush=True)

    def on_properties_changed(self, bus_name: str, property, invalidated):
        props = parse_dbus_values(property)
        self.players[bus_name].update_props(props)
        match props:
            case {"PlaybackStatus": "Playing"}:
                if bus_name in self.active_players:
                    self.active_players.remove(bus_name)
                self.active_players.append(bus_name)
            case {"PlaybackStatus": "Stopped"}:
                self.active_players.remove(bus_name)

        self.update_printer()

    async def add_player(self, bus_name):
        properties = None
        self.players[bus_name] = None
        self.ifaces[bus_name] = None

        obj = self.bus.get_proxy_object(
            bus_name, OBJECT_PATH, await self.bus.introspect(bus_name, OBJECT_PATH)
        )

        properties = obj.get_interface(PROPERTIES_INTERFACE)

        self.players[bus_name] = Printer(
            parse_dbus_values(await properties.call_get_all(PLAYER_INTERFACE))
        )
        self.ifaces[bus_name] = obj.get_interface(PLAYER_INTERFACE)

        properties.on_properties_changed(
            lambda _, p, i: self.on_properties_changed(bus_name, p, i)
        )

        if bus_name in self.active_players:
            self.active_players.remove(bus_name)

        match self.players[bus_name].player.get("PlaybackStatus"):
            case "Playing":
                self.active_players.append(bus_name)
                self.update_printer()
            case "Paused":
                self.active_players.appendleft(bus_name)
                self.update_printer()

    def remove_player(self, bus_name):
        self.players.pop(bus_name, None)
        self.ifaces.pop(bus_name, None)
        if bus_name in self.active_players:
            self.active_players.remove(bus_name)
            self.update_printer()

    async def on_name_owner_changed(self, bus_name, old, new):
        if self.valid_player(bus_name):
            if old:
                self.remove_player(bus_name)
            if new:
                await self.add_player(bus_name)

    async def listener(self):
        self.dbus_iface.on_name_owner_changed(self.on_name_owner_changed)
        await self.bus.wait_for_disconnect()

    async def button_handler(self):
        loop = asyncio.get_event_loop()
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        await loop.connect_read_pipe(lambda: protocol, sys.stdin)

        while True:
            line = await reader.readline()

            if not line:
                await asyncio.sleep(1)
                continue

            match json.loads(line):
                case {"button": 1} if bus_name := self.active_player:
                    await self.ifaces[bus_name].call_play_pause()
                case {"button": 2}:
                    pass
                case {"button": 3}:
                    self.cycle_player()
                case {"button": 4} if bus_name := self.active_player:
                    iface = self.ifaces[bus_name]
                    if callable(getattr(iface.__class__, "get_volume", None)):
                        volume = await iface.get_volume()
                        if callable(getattr(iface.__class__, "set_volume", None)):
                            await iface.set_volume(volume + 0.05)
                case {"button": 5} if bus_name := self.active_player:
                    iface = self.ifaces[bus_name]
                    if callable(getattr(iface.__class__, "get_volume", None)):
                        volume = await iface.get_volume()
                        if callable(getattr(iface.__class__, "set_volume", None)):
                            await self.ifaces[bus_name].set_volume(volume - 0.05)


async def main():
    try:
        async with TaskGroup() as task_group:
            mpris = await MPRIS.connect(task_group)
            task_group.create_task(mpris.listener())
            task_group.create_task(mpris.button_handler())
    except CancelledError:
        return


if __name__ == "__main__":
    run(main())
