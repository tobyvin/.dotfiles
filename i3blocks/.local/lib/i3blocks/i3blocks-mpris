#!/usr/bin/env python3

import asyncio
import json
import os
import sys
from asyncio import CancelledError, TaskGroup, run
from collections import defaultdict, deque
from functools import cached_property
from itertools import islice

from dbus_next import Variant
from dbus_next.aio import MessageBus
from dbus_next.errors import DBusError

BUS_NAME_PREFIX = "org.mpris.MediaPlayer2."
BUS_NAME_IGNORE = ["org.mpris.MediaPlayer2.playerctld"]
OBJECT_PATH = "/org/mpris/MediaPlayer2"
PLAYER_INTERFACE = "org.mpris.MediaPlayer2.Player"
PROPERTIES_INTERFACE = "org.freedesktop.DBus.Properties"


def parse_dbus_values(item: Variant | dict | list) -> dict:
    match item:
        case Variant():
            return parse_dbus_values(item.value)
        case dict(item):
            return {k: parse_dbus_values(v) for k, v in item.items()}
        case list(item):
            return [parse_dbus_values(v) for v in item]
        case v:
            return v


class Printer:
    BLACK = f"#{os.environ.get("BASE16_COLOR_00_HEX")}"
    GREEN = f"#{os.environ.get("BASE16_COLOR_0C_HEX")}"
    YELLOW = f"#{os.environ.get("BASE16_COLOR_0A_HEX")}"
    ICONS = {
        "icon": "\U000f075a",  # 󰝚
        "prev": "\U000f04ae",  # 󰒮
        "play": "\U000f040a",  # 󰐊
        "pause": "\U000f03e4",  # 󰏤
        "next": "\U000f04ad",  # 󰒭
        "high": "\U000f057e",  # 󰕾
        "med": "\U000f0580",  # 󰖀
        "low": "\U000f057f",  # 󰕿
    }

    def __init__(self, player, width: int = 10):
        self.width = width
        self.player = player

    def __iter__(self):
        while self.iter:
            yield {
                "full_text": self.full_text,
                "short_text": self.short_text,
                "color": self.color,
                "background": self.background,
            }

            if len(self.iter) > self.width:
                self.iter.rotate(-1)
            else:
                break

    @property
    def player(self):
        return self._player

    @player.setter
    def player(self, value):
        self._player = value
        # clear possibly outdated properties
        # See: https://stackoverflow.com/a/69367025/11477336
        for attr in [
            "title",
            "controls",
            "volume",
            "color",
            "background",
            "short_text",
        ]:
            self.__dict__.pop(attr, None)

    @cached_property
    def title(self):
        title = self.player.get("Metadata", {"xesam:title": self.prev_title}).get(
            "xesam:title"
        )
        if title != self.prev_title:
            self.__dict__.pop("iter", None)
            self.prev_title = title
        return self.prev_title

    @cached_property
    def controls(self) -> str:
        controls = []

        if self.player.get("CanGoPrevious"):
            controls.append(Printer.ICONS["prev"])

        match self.player.get("PlaybackStatus"):
            case "Playing" if self.player.get("CanPause"):
                controls.append(Printer.ICONS["pause"])
            case _ if self.player.get("CanPlay"):
                controls.append(Printer.ICONS["play"])

        if self.player.get("CanGoNext"):
            controls.append(Printer.ICONS["next"])

        if len(controls) > 0:
            return "  ".join(controls) + " "

    @cached_property
    def volume(self) -> str:
        match self.player.get("Volume"):
            case float(vol) if vol > 0.66:
                return f"{Printer.ICONS["high"]} {vol:.0%}"
            case float(vol) if vol > 0.33:
                return f"{Printer.ICONS["med"]} {vol:.0%}"
            case float(vol):
                return f"{Printer.ICONS["low"]} {vol:.0%}"

    @cached_property
    def background(self):
        match self.player.get("PlaybackStatus"):
            case "Playing":
                return Printer.GREEN
            case "Paused":
                return Printer.YELLOW
            case _:
                return None

    @cached_property
    def color(self):
        match self.player.get("PlaybackStatus"):
            case "Playing" | "Paused":
                return Printer.BLACK
            case _:
                return None

    @cached_property
    def iter(self) -> list | deque:
        match self.player.get("Metadata", {}).get("xesam:title", ""):
            case str(""):
                return [""]
            case str(s):
                return deque(list(s + " "))

    @cached_property
    def short_text(self) -> str:
        s = f" {Printer.ICONS["icon"]} "
        if c := self.controls:
            s += f" {c} "
        return s

    @property
    def full_text(self) -> str:
        s = f" {Printer.ICONS["icon"]} {"".join(islice(self.iter, 0, self.width))} "

        if c := self.controls:
            s += f"{c} "

        if v := self.volume:
            s += f"{v} "

        return s

    async def print(self):
        for status in iter(self):
            print(json.dumps(status, ensure_ascii=False), flush=True)
            await asyncio.sleep(0.5)


class MPRIS:
    def __init__(self, task_group: TaskGroup):
        self.task_group = task_group
        self.printer_task = None
        self.active_players = deque([])
        self.bus = None
        self.dbus_iface = None
        self.players = defaultdict(lambda: {})
        self.player_iter = self.players.keys()
        self.ifaces = {}

    @classmethod
    async def connect(cls, task_group: TaskGroup):
        self = cls(task_group)
        self.bus = await MessageBus().connect()

        self.dbus_iface = self.bus.get_proxy_object(
            "org.freedesktop.DBus",
            "/org/freedesktop/DBus",
            await self.bus.introspect("org.freedesktop.DBus", "/org/freedesktop/DBus"),
        ).get_interface("org.freedesktop.DBus")

        for bus_name in await self.dbus_iface.call_list_names():
            if self.valid_player(bus_name):
                await self.add_player(bus_name)

        return self

    @staticmethod
    def valid_player(bus_name: str) -> bool:
        return bus_name.startswith(BUS_NAME_PREFIX) and bus_name not in BUS_NAME_IGNORE

    @property
    def active_player(self):
        if len(self.active_players) > 0:
            return self.active_players[-1]

    def cycle_player(self):
        self.active_players.rotate(-1)
        self.update_printer()

    def update_printer(self):
        if self.printer_task is not None:
            self.printer_task.cancel()

        if len(self.active_players) > 0:
            self.printer_task = self.task_group.create_task(
                self.players[self.active_player].print()
            )
        else:
            print(flush=True)

    def on_properties_changed(self, bus_name: str, property, invalidated):
        props = parse_dbus_values(property)
        self.players[bus_name].player |= props
        match props:
            case {"PlaybackStatus": "Playing"}:
                if bus_name in self.active_players:
                    self.active_players.remove(bus_name)
                self.active_players.append(bus_name)
            case {"PlaybackStatus": "Stopped"}:
                self.active_players.remove(bus_name)

        self.update_printer()

    async def add_player(self, bus_name):
        properties = None
        self.players[bus_name] = None
        self.ifaces[bus_name] = None

        obj = self.bus.get_proxy_object(
            bus_name, OBJECT_PATH, await self.bus.introspect(bus_name, OBJECT_PATH)
        )

        properties = obj.get_interface(PROPERTIES_INTERFACE)

        self.players[bus_name] = Printer(
            parse_dbus_values(await properties.call_get_all(PLAYER_INTERFACE))
        )
        self.ifaces[bus_name] = obj.get_interface(PLAYER_INTERFACE)

        properties.on_properties_changed(
            lambda _, p, i: self.on_properties_changed(bus_name, p, i)
        )

        if bus_name in self.active_players:
            self.active_players.remove(bus_name)

        match self.players[bus_name].player.get("PlaybackStatus"):
            case "Playing":
                self.active_players.append(bus_name)
                self.update_printer()
            case "Paused":
                self.active_players.appendleft(bus_name)
                self.update_printer()

    def remove_player(self, bus_name):
        self.players.pop(bus_name, None)
        self.ifaces.pop(bus_name, None)
        if bus_name in self.active_players:
            self.active_players.remove(bus_name)
            self.update_printer()

    async def on_name_owner_changed(self, bus_name, old, new):
        if self.valid_player(bus_name):
            if old:
                self.remove_player(bus_name)
            if new:
                await self.add_player(bus_name)

    async def listener(self):
        self.dbus_iface.on_name_owner_changed(self.on_name_owner_changed)
        await self.bus.wait_for_disconnect()

    async def button_handler(self):
        loop = asyncio.get_event_loop()
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        await loop.connect_read_pipe(lambda: protocol, sys.stdin)

        while True:
            line = await reader.readline()

            if not line:
                await asyncio.sleep(1)
                continue

            try:
                match json.loads(line):
                    case {"button": 1} if bus_name := self.active_player:
                        await self.ifaces[bus_name].call_play_pause()
                    case {"button": 2}:
                        pass
                    case {"button": 3}:
                        self.cycle_player()
                    case {"button": 4} if bus_name := self.active_player:
                        volume = await self.ifaces[bus_name].get_volume()
                        await self.ifaces[bus_name].set_volume(volume + 0.05)
                    case {"button": 5} if bus_name := self.active_player:
                        volume = await self.ifaces[bus_name].get_volume()
                        await self.ifaces[bus_name].set_volume(volume - 0.05)
            except DBusError:
                pass


async def main():
    try:
        async with TaskGroup() as task_group:
            mpris = await MPRIS.connect(task_group)
            task_group.create_task(mpris.listener())
            task_group.create_task(mpris.button_handler())
    except CancelledError:
        return


if __name__ == "__main__":
    run(main())
